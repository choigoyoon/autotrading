"""
This type stub file was generated by pyright.
"""

import operator
from numba.core import types
from numba.core.imputils import RefType, iternext_impl, lower_builtin, lower_cast

"""
Support for native homogeneous sets.
"""
def get_payload_struct(context, builder, set_type, ptr):
    """
    Given a set value and type, get its payload structure (as a
    reference, so that mutations are seen by all).
    """
    ...

def get_entry_size(context, set_type):
    """
    Return the entry size for the given set type.
    """
    ...

EMPTY = ...
DELETED = ...
FALLBACK = ...
MINSIZE = ...
LINEAR_PROBES = ...
DEBUG_ALLOCS = ...
def get_hash_value(context, builder, typ, value):
    """
    Compute the hash of the given value.
    """
    ...

def is_hash_empty(context, builder, h):
    """
    Whether the hash value denotes an empty entry.
    """
    ...

def is_hash_deleted(context, builder, h):
    """
    Whether the hash value denotes a deleted entry.
    """
    ...

def is_hash_used(context, builder, h):
    """
    Whether the hash value denotes an active entry.
    """
    ...

SetLoop = ...
class _SetPayload:
    def __init__(self, context, builder, set_type, ptr) -> None:
        ...
    
    @property
    def mask(self):
        ...
    
    @mask.setter
    def mask(self, value): # -> None:
        ...
    
    @property
    def used(self):
        ...
    
    @used.setter
    def used(self, value): # -> None:
        ...
    
    @property
    def fill(self):
        ...
    
    @fill.setter
    def fill(self, value): # -> None:
        ...
    
    @property
    def finger(self):
        ...
    
    @finger.setter
    def finger(self, value): # -> None:
        ...
    
    @property
    def dirty(self):
        ...
    
    @dirty.setter
    def dirty(self, value): # -> None:
        ...
    
    @property
    def entries(self):
        """
        A pointer to the start of the entries array.
        """
        ...
    
    @property
    def ptr(self): # -> Any:
        """
        A pointer to the start of the NRT-allocated area.
        """
        ...
    
    def get_entry(self, idx):
        """
        Get entry number *idx*.
        """
        ...
    


class SetInstance:
    def __init__(self, context, builder, set_type, set_val) -> None:
        ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def payload(self): # -> _SetPayload:
        """
        The _SetPayload for this set.
        """
        ...
    
    @property
    def value(self):
        ...
    
    @property
    def meminfo(self):
        ...
    
    @property
    def parent(self):
        ...
    
    @parent.setter
    def parent(self, value): # -> None:
        ...
    
    def get_size(self):
        """
        Return the number of elements in the size.
        """
        ...
    
    def set_dirty(self, val): # -> None:
        ...
    
    def add(self, item, do_resize=...): # -> None:
        ...
    
    def add_pyapi(self, pyapi, item, do_resize=...): # -> None:
        """A version of .add for use inside functions following Python calling
        convention.
        """
        ...
    
    def contains(self, item):
        ...
    
    def discard(self, item):
        ...
    
    def pop(self):
        ...
    
    def clear(self): # -> None:
        ...
    
    def copy(self): # -> Self:
        """
        Return a copy of this set.
        """
        ...
    
    def intersect(self, other): # -> None:
        """
        In-place intersection with *other* set.
        """
        ...
    
    def difference(self, other): # -> None:
        """
        In-place difference with *other* set.
        """
        ...
    
    def symmetric_difference(self, other): # -> None:
        """
        In-place symmetric difference with *other* set.
        """
        ...
    
    def issubset(self, other, strict=...):
        ...
    
    def isdisjoint(self, other):
        ...
    
    def equals(self, other):
        ...
    
    @classmethod
    def allocate_ex(cls, context, builder, set_type, nitems=...): # -> tuple[Any, Self]:
        """
        Allocate a SetInstance with its storage.
        Return a (ok, instance) tuple where *ok* is a LLVM boolean and
        *instance* is a SetInstance object (the object's contents are
        only valid when *ok* is true).
        """
        ...
    
    @classmethod
    def allocate(cls, context, builder, set_type, nitems=...): # -> Self:
        """
        Allocate a SetInstance with its storage.  Same as allocate_ex(),
        but return an initialized *instance*.  If allocation failed,
        control is transferred to the caller using the target's current
        call convention.
        """
        ...
    
    @classmethod
    def from_meminfo(cls, context, builder, set_type, meminfo): # -> Self:
        """
        Allocate a new set instance pointing to an existing payload
        (a meminfo pointer).
        Note the parent field has to be filled by the caller.
        """
        ...
    
    @classmethod
    def choose_alloc_size(cls, context, builder, nitems):
        """
        Choose a suitable number of entries for the given number of items.
        """
        ...
    
    def upsize(self, nitems): # -> None:
        """
        When adding to the set, ensure it is properly sized for the given
        number of used entries.
        """
        ...
    
    def downsize(self, nitems): # -> None:
        """
        When removing from the set, ensure it is properly sized for the given
        number of used entries.
        """
        ...
    
    def incref_value(self, val): # -> None:
        """Incref an element value
        """
        ...
    
    def decref_value(self, val): # -> None:
        """Decref an element value
        """
        ...
    


class SetIterInstance:
    def __init__(self, context, builder, iter_type, iter_val) -> None:
        ...
    
    @classmethod
    def from_set(cls, context, builder, iter_type, set_val): # -> Self:
        ...
    
    @property
    def value(self):
        ...
    
    @property
    def meminfo(self):
        ...
    
    @property
    def index(self):
        ...
    
    @index.setter
    def index(self, value): # -> None:
        ...
    
    def iternext(self, result): # -> None:
        ...
    


def build_set(context, builder, set_type, items):
    """
    Build a set of the given type, containing the given items.
    """
    ...

@lower_builtin(set)
def set_empty_constructor(context, builder, sig, args):
    ...

@lower_builtin(set, types.IterableType)
def set_constructor(context, builder, sig, args):
    ...

@lower_builtin(len, types.Set)
def set_len(context, builder, sig, args):
    ...

@lower_builtin(operator.contains, types.Set, types.Any)
def in_set(context, builder, sig, args):
    ...

@lower_builtin('getiter', types.Set)
def getiter_set(context, builder, sig, args):
    ...

@lower_builtin('iternext', types.SetIter)
@iternext_impl(RefType.BORROWED)
def iternext_listiter(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin("set.add", types.Set, types.Any)
def set_add(context, builder, sig, args):
    ...

@lower_builtin("set.discard", types.Set, types.Any)
def set_discard(context, builder, sig, args):
    ...

@lower_builtin("set.pop", types.Set)
def set_pop(context, builder, sig, args):
    ...

@lower_builtin("set.remove", types.Set, types.Any)
def set_remove(context, builder, sig, args):
    ...

@lower_builtin("set.clear", types.Set)
def set_clear(context, builder, sig, args):
    ...

@lower_builtin("set.copy", types.Set)
def set_copy(context, builder, sig, args):
    ...

@lower_builtin("set.difference_update", types.Set, types.IterableType)
def set_difference_update(context, builder, sig, args):
    ...

@lower_builtin("set.intersection_update", types.Set, types.Set)
def set_intersection_update(context, builder, sig, args):
    ...

@lower_builtin("set.symmetric_difference_update", types.Set, types.Set)
def set_symmetric_difference_update(context, builder, sig, args):
    ...

@lower_builtin("set.update", types.Set, types.IterableType)
def set_update(context, builder, sig, args):
    ...

@lower_builtin(operator.sub, types.Set, types.Set)
@lower_builtin("set.difference", types.Set, types.Set)
def set_difference(context, builder, sig, args):
    ...

@lower_builtin(operator.and_, types.Set, types.Set)
@lower_builtin("set.intersection", types.Set, types.Set)
def set_intersection(context, builder, sig, args):
    ...

@lower_builtin(operator.xor, types.Set, types.Set)
@lower_builtin("set.symmetric_difference", types.Set, types.Set)
def set_symmetric_difference(context, builder, sig, args):
    ...

@lower_builtin(operator.or_, types.Set, types.Set)
@lower_builtin("set.union", types.Set, types.Set)
def set_union(context, builder, sig, args):
    ...

@lower_builtin("set.isdisjoint", types.Set, types.Set)
def set_isdisjoint(context, builder, sig, args):
    ...

@lower_builtin(operator.le, types.Set, types.Set)
@lower_builtin("set.issubset", types.Set, types.Set)
def set_issubset(context, builder, sig, args):
    ...

@lower_builtin(operator.ge, types.Set, types.Set)
@lower_builtin("set.issuperset", types.Set, types.Set)
def set_issuperset(context, builder, sig, args):
    ...

@lower_builtin(operator.eq, types.Set, types.Set)
def set_isdisjoint(context, builder, sig, args):
    ...

@lower_builtin(operator.ne, types.Set, types.Set)
def set_ne(context, builder, sig, args):
    ...

@lower_builtin(operator.lt, types.Set, types.Set)
def set_lt(context, builder, sig, args):
    ...

@lower_builtin(operator.gt, types.Set, types.Set)
def set_gt(context, builder, sig, args):
    ...

@lower_builtin(operator.is_, types.Set, types.Set)
def set_is(context, builder, sig, args):
    ...

@lower_cast(types.Set, types.Set)
def set_to_set(context, builder, fromty, toty, val):
    ...

