"""
This type stub file was generated by pyright.
"""

from numba.core import typing
from numba.core.utils import cached_property
from numba.core.base import BaseContext
from numba.core.callconv import MinimalCallConv

class CUDATypingContext(typing.BaseContext):
    def load_additional_registries(self): # -> None:
        ...
    
    def resolve_value_type(self, val): # -> ByteArray | PyArray | Buffer | ExternalFunctionPointer | Opaque | Any | ExternalFunction | Module:
        ...
    


VALID_CHARS = ...
class CUDATargetContext(BaseContext):
    implement_powi_as_math_call = ...
    strict_alignment = ...
    def __init__(self, typingctx, target=...) -> None:
        ...
    
    @property
    def DIBuilder(self): # -> type[DIBuilder] | type[NvvmDIBuilder]:
        ...
    
    @property
    def enable_boundscheck(self): # -> Literal[False]:
        ...
    
    def create_module(self, name): # -> Module:
        ...
    
    def init(self): # -> None:
        ...
    
    def load_additional_registries(self): # -> None:
        ...
    
    def codegen(self): # -> JITCUDACodegen:
        ...
    
    @property
    def target_data(self): # -> TargetData:
        ...
    
    @cached_property
    def nonconst_module_attrs(self): # -> tuple[tuple[Module, str], ...]:
        """
        Some CUDA intrinsics are at the module level, but cannot be treated as
        constants, because they are loaded from a special register in the PTX.
        These include threadIdx, blockDim, etc.
        """
        ...
    
    @cached_property
    def call_conv(self): # -> CUDACallConv:
        ...
    
    def mangler(self, name, argtypes, *, abi_tags=..., uid=...): # -> str:
        ...
    
    def prepare_cuda_kernel(self, codelib, fndesc, debug, nvvm_options, filename, linenum, max_registers=...): # -> tuple[Any, Any]:
        """
        Adapt a code library ``codelib`` with the numba compiled CUDA kernel
        with name ``fname`` and arguments ``argtypes`` for NVVM.
        A new library is created with a wrapper function that can be used as
        the kernel entry point for the given kernel.

        Returns the new code library and the wrapper function.

        Parameters:

        codelib:       The CodeLibrary containing the device function to wrap
                       in a kernel call.
        fndesc:        The FunctionDescriptor of the source function.
        debug:         Whether to compile with debug.
        nvvm_options:  Dict of NVVM options used when compiling the new library.
        filename:      The source filename that the function is contained in.
        linenum:       The source line that the function is on.
        max_registers: The max_registers argument for the code library.
        """
        ...
    
    def generate_kernel_wrapper(self, library, fndesc, kernel_name, debug, filename, linenum):
        """
        Generate the kernel wrapper in the given ``library``.
        The function being wrapped is described by ``fndesc``.
        The wrapper function is returned.
        """
        ...
    
    def make_constant_array(self, builder, aryty, arr):
        """
        Unlike the parent version.  This returns a a pointer in the constant
        addrspace.
        """
        ...
    
    def insert_const_string(self, mod, string): # -> None:
        """
        Unlike the parent version.  This returns a a pointer in the constant
        addrspace.
        """
        ...
    
    def insert_string_const_addrspace(self, builder, string):
        """
        Insert a constant string in the constant addresspace and return a
        generic i8 pointer to the data.

        This function attempts to deduplicate.
        """
        ...
    
    def insert_addrspace_conv(self, builder, ptr, addrspace):
        """
        Perform addrspace conversion according to the NVVM spec
        """
        ...
    
    def optimize_function(self, func): # -> None:
        """Run O1 function passes
        """
        ...
    


class CUDACallConv(MinimalCallConv):
    ...


