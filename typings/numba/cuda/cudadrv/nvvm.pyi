"""
This type stub file was generated by pyright.
"""

from ctypes import c_int, c_void_p

"""
This is a direct translation of nvvm.h
"""
logger = ...
ADDRSPACE_GENERIC = ...
ADDRSPACE_GLOBAL = ...
ADDRSPACE_SHARED = ...
ADDRSPACE_CONSTANT = ...
ADDRSPACE_LOCAL = ...
nvvm_program = c_void_p
nvvm_result = c_int
RESULT_CODE_NAMES = ...
def is_available(): # -> bool:
    """
    Return if libNVVM is available
    """
    ...

_nvvm_lock = ...
class NVVM:
    '''Process-wide singleton.
    '''
    _PROTOTYPES = ...
    __INSTANCE = ...
    def __new__(cls): # -> Self:
        ...
    
    def __init__(self) -> None:
        ...
    
    @property
    def is_nvvm70(self): # -> bool:
        ...
    
    def get_version(self): # -> tuple[int, int]:
        ...
    
    def get_ir_version(self): # -> tuple[int, int, int, int]:
        ...
    
    def check_error(self, error, msg, exit=...): # -> None:
        ...
    


class CompilationUnit:
    def __init__(self) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def add_module(self, buffer): # -> None:
        """
         Add a module level NVVM IR to a compilation unit.
         - The buffer should contain an NVVM module IR either in the bitcode
           representation (LLVM3.0) or in the text representation.
        """
        ...
    
    def lazy_add_module(self, buffer): # -> None:
        """
        Lazily add an NVVM IR module to a compilation unit.
        The buffer should contain NVVM module IR either in the bitcode
        representation or in the text representation.
        """
        ...
    
    def compile(self, **options): # -> list[Any]:
        """Perform Compilation

        The valid compiler options are

         *   - -g (enable generation of debugging information)
         *   - -opt=
         *     - 0 (disable optimizations)
         *     - 3 (default, enable optimizations)
         *   - -arch=
         *     - compute_20 (default)
         *     - compute_30
         *     - compute_35
         *   - -ftz=
         *     - 0 (default, preserve denormal values, when performing
         *          single-precision floating-point operations)
         *     - 1 (flush denormal values to zero, when performing
         *          single-precision floating-point operations)
         *   - -prec-sqrt=
         *     - 0 (use a faster approximation for single-precision
         *          floating-point square root)
         *     - 1 (default, use IEEE round-to-nearest mode for
         *          single-precision floating-point square root)
         *   - -prec-div=
         *     - 0 (use a faster approximation for single-precision
         *          floating-point division and reciprocals)
         *     - 1 (default, use IEEE round-to-nearest mode for
         *          single-precision floating-point division and reciprocals)
         *   - -fma=
         *     - 0 (disable FMA contraction)
         *     - 1 (default, enable FMA contraction)
         *
         """
        ...
    
    def get_log(self): # -> Any | Literal['']:
        ...
    


data_layout = ...
_supported_cc = ...
def get_supported_ccs(): # -> tuple[()] | tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]] | tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]] | tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]] | tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
    ...

def find_closest_arch(mycc): # -> tuple[int, int]:
    """
    Given a compute capability, return the closest compute capability supported
    by the CUDA toolkit.

    :param mycc: Compute capability as a tuple ``(MAJOR, MINOR)``
    :return: Closest supported CC as a tuple ``(MAJOR, MINOR)``
    """
    ...

def get_arch_option(major, minor): # -> str:
    """Matches with the closest architecture option
    """
    ...

MISSING_LIBDEVICE_FILE_MSG = ...
class LibDevice:
    _cache_ = ...
    def __init__(self) -> None:
        ...
    
    def get(self): # -> bytes:
        ...
    


ir_numba_cas_hack = ...
cas_nvvm70 = ...
cas_nvvm34 = ...
ir_numba_atomic_binary_template = ...
ir_numba_atomic_inc_template = ...
ir_numba_atomic_dec_template = ...
ir_numba_atomic_minmax_template = ...
def ir_cas(Ti): # -> str:
    ...

def ir_numba_atomic_binary(T, Ti, OP, FUNC): # -> str:
    ...

def ir_numba_atomic_minmax(T, Ti, NAN, OP, PTR_OR_VAL, FUNC): # -> str:
    ...

def ir_numba_atomic_inc(T, Tu): # -> str:
    ...

def ir_numba_atomic_dec(T, Tu): # -> str:
    ...

def llvm_replace(llvmir): # -> LiteralString:
    ...

def llvm_to_ptx(llvmir, **opts): # -> list[Any]:
    ...

re_metadata_def = ...
re_metadata_correct_usage = ...
re_metadata_ref = ...
debuginfo_pattern = ...
re_metadata_debuginfo = ...
re_attributes_def = ...
supported_attributes = ...
re_getelementptr = ...
re_load = ...
re_call = ...
re_range = ...
re_type_tok = ...
re_annotations = ...
re_unsupported_keywords = ...
re_parenthesized_list = ...
re_spflags = ...
spflagmap = ...
def llvm100_to_70_ir(ir): # -> LiteralString:
    """
    Convert LLVM 10.0 IR for LLVM 7.0.
    """
    ...

def llvm100_to_34_ir(ir): # -> LiteralString:
    """
    Convert LLVM 10.0 IR for LLVM 3.4.
    """
    ...

def set_cuda_kernel(lfunc): # -> None:
    ...

def add_ir_version(mod): # -> None:
    """Add NVVM IR version to module"""
    ...

def fix_data_layout(module): # -> None:
    ...

