"""
This type stub file was generated by pyright.
"""

class DataFlowAnalysis:
    """
    Perform stack2reg

    This is necessary to resolve blocks that propagates stack value.
    This would allow the use of `and` and `or` and python2.6 jumps.
    """
    def __init__(self, cfa) -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def run_on_block(self, blk): # -> BlockInfo:
        ...
    
    def dump(self): # -> None:
        ...
    
    def dispatch(self, info, inst): # -> None:
        ...
    
    def handle_unknown_opcode(self, info, inst):
        ...
    
    def dup_topx(self, info, inst, count): # -> None:
        ...
    
    def add_syntax_block(self, info, block): # -> None:
        """
        Add an inner syntax block.
        """
        ...
    
    def pop_syntax_block(self, info):
        """
        Pop the innermost syntax block and revert its stack effect.
        """
        ...
    
    def op_NOP(self, info, inst): # -> None:
        ...
    
    def op_DUP_TOPX(self, info, inst): # -> None:
        ...
    
    def op_DUP_TOP(self, info, inst): # -> None:
        ...
    
    def op_DUP_TOP_TWO(self, info, inst): # -> None:
        ...
    
    def op_ROT_TWO(self, info, inst): # -> None:
        ...
    
    def op_ROT_THREE(self, info, inst): # -> None:
        ...
    
    def op_ROT_FOUR(self, info, inst): # -> None:
        ...
    
    def op_UNPACK_SEQUENCE(self, info, inst): # -> None:
        ...
    
    def op_FORMAT_VALUE(self, info, inst): # -> None:
        """
        FORMAT_VALUE(flags): flags argument specifies format spec which is
        not supported yet. Currently, str() is simply called on the value.
        Pops a value from stack and pushes results back.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
        """
        ...
    
    def op_BUILD_STRING(self, info, inst): # -> None:
        """
        BUILD_STRING(count): Concatenates count strings from the stack and
        pushes the resulting string onto the stack.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
        """
        ...
    
    def op_BUILD_TUPLE(self, info, inst): # -> None:
        ...
    
    def op_BUILD_LIST(self, info, inst): # -> None:
        ...
    
    def op_LIST_APPEND(self, info, inst): # -> None:
        ...
    
    def op_BUILD_MAP(self, info, inst): # -> None:
        ...
    
    def op_MAP_ADD(self, info, inst): # -> None:
        ...
    
    def op_BUILD_SET(self, info, inst): # -> None:
        ...
    
    def op_POP_TOP(self, info, inst): # -> None:
        ...
    
    def op_STORE_ATTR(self, info, inst): # -> None:
        ...
    
    def op_DELETE_ATTR(self, info, inst): # -> None:
        ...
    
    def op_STORE_FAST(self, info, inst): # -> None:
        ...
    
    def op_STORE_MAP(self, info, inst): # -> None:
        ...
    
    def op_STORE_DEREF(self, info, inst): # -> None:
        ...
    
    def op_LOAD_FAST(self, info, inst): # -> None:
        ...
    
    def op_LOAD_CONST(self, info, inst): # -> None:
        ...
    
    def op_LOAD_GLOBAL(self, info, inst): # -> None:
        ...
    
    def op_LOAD_DEREF(self, info, inst): # -> None:
        ...
    
    def op_LOAD_ATTR(self, info, inst): # -> None:
        ...
    
    def op_BINARY_SUBSCR(self, info, inst): # -> None:
        ...
    
    def op_STORE_SUBSCR(self, info, inst): # -> None:
        ...
    
    def op_DELETE_SUBSCR(self, info, inst): # -> None:
        ...
    
    def op_GET_ITER(self, info, inst): # -> None:
        ...
    
    def op_FOR_ITER(self, info, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION(self, info, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION_KW(self, info, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION_EX(self, info, inst): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, info, inst): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK(self, info, inst): # -> None:
        ...
    
    def op_BUILD_CONST_KEY_MAP(self, info, inst): # -> None:
        ...
    
    def op_PRINT_ITEM(self, info, inst): # -> None:
        ...
    
    def op_PRINT_NEWLINE(self, info, inst): # -> None:
        ...
    
    op_UNARY_NEGATIVE = ...
    op_UNARY_POSITIVE = ...
    op_UNARY_NOT = ...
    op_UNARY_INVERT = ...
    op_COMPARE_OP = ...
    op_IS_OP = ...
    op_CONTAINS_OP = ...
    op_INPLACE_ADD = ...
    op_INPLACE_SUBTRACT = ...
    op_INPLACE_MULTIPLY = ...
    op_INPLACE_DIVIDE = ...
    op_INPLACE_TRUE_DIVIDE = ...
    op_INPLACE_FLOOR_DIVIDE = ...
    op_INPLACE_MODULO = ...
    op_INPLACE_POWER = ...
    op_INPLACE_MATRIX_MULTIPLY = ...
    op_INPLACE_LSHIFT = ...
    op_INPLACE_RSHIFT = ...
    op_INPLACE_AND = ...
    op_INPLACE_OR = ...
    op_INPLACE_XOR = ...
    op_BINARY_ADD = ...
    op_BINARY_SUBTRACT = ...
    op_BINARY_MULTIPLY = ...
    op_BINARY_DIVIDE = ...
    op_BINARY_TRUE_DIVIDE = ...
    op_BINARY_FLOOR_DIVIDE = ...
    op_BINARY_MODULO = ...
    op_BINARY_POWER = ...
    op_BINARY_MATRIX_MULTIPLY = ...
    op_BINARY_LSHIFT = ...
    op_BINARY_RSHIFT = ...
    op_BINARY_AND = ...
    op_BINARY_OR = ...
    op_BINARY_XOR = ...
    def op_SLICE_0(self, info, inst): # -> None:
        """
        TOS = TOS[:]
        """
        ...
    
    def op_SLICE_1(self, info, inst): # -> None:
        """
        TOS = TOS1[TOS:]
        """
        ...
    
    def op_SLICE_2(self, info, inst): # -> None:
        """
        TOS = TOS1[:TOS]
        """
        ...
    
    def op_SLICE_3(self, info, inst): # -> None:
        """
        TOS = TOS2[TOS1:TOS]
        """
        ...
    
    def op_STORE_SLICE_0(self, info, inst): # -> None:
        """
        TOS[:] = TOS1
        """
        ...
    
    def op_STORE_SLICE_1(self, info, inst): # -> None:
        """
        TOS1[TOS:] = TOS2
        """
        ...
    
    def op_STORE_SLICE_2(self, info, inst): # -> None:
        """
        TOS1[:TOS] = TOS2
        """
        ...
    
    def op_STORE_SLICE_3(self, info, inst): # -> None:
        """
        TOS2[TOS1:TOS] = TOS3
        """
        ...
    
    def op_DELETE_SLICE_0(self, info, inst): # -> None:
        """
        del TOS[:]
        """
        ...
    
    def op_DELETE_SLICE_1(self, info, inst): # -> None:
        """
        del TOS1[TOS:]
        """
        ...
    
    def op_DELETE_SLICE_2(self, info, inst): # -> None:
        """
        del TOS1[:TOS]
        """
        ...
    
    def op_DELETE_SLICE_3(self, info, inst): # -> None:
        """
        del TOS2[TOS1:TOS]
        """
        ...
    
    def op_BUILD_SLICE(self, info, inst): # -> None:
        """
        slice(TOS1, TOS) or slice(TOS2, TOS1, TOS)
        """
        ...
    
    def op_POP_JUMP_IF_TRUE(self, info, inst): # -> None:
        ...
    
    def op_POP_JUMP_IF_FALSE(self, info, inst): # -> None:
        ...
    
    def op_JUMP_IF_TRUE(self, info, inst): # -> None:
        ...
    
    def op_JUMP_IF_FALSE(self, info, inst): # -> None:
        ...
    
    op_JUMP_IF_FALSE_OR_POP = ...
    op_JUMP_IF_TRUE_OR_POP = ...
    def op_JUMP_ABSOLUTE(self, info, inst): # -> None:
        ...
    
    def op_JUMP_FORWARD(self, info, inst): # -> None:
        ...
    
    def op_BREAK_LOOP(self, info, inst): # -> None:
        ...
    
    def op_RETURN_VALUE(self, info, inst): # -> None:
        ...
    
    def op_YIELD_VALUE(self, info, inst): # -> None:
        ...
    
    def op_SETUP_LOOP(self, info, inst): # -> None:
        ...
    
    def op_SETUP_WITH(self, info, inst): # -> None:
        ...
    
    def op_WITH_CLEANUP(self, info, inst): # -> None:
        """
        Note: py2 only opcode
        """
        ...
    
    def op_WITH_CLEANUP_START(self, info, inst): # -> None:
        ...
    
    def op_WITH_CLEANUP_FINISH(self, info, inst): # -> None:
        ...
    
    def op_END_FINALLY(self, info, inst): # -> None:
        ...
    
    def op_POP_BLOCK(self, info, inst): # -> None:
        ...
    
    def op_RAISE_VARARGS(self, info, inst): # -> None:
        ...
    
    def op_MAKE_FUNCTION(self, info, inst, MAKE_CLOSURE=...): # -> None:
        ...
    
    def op_MAKE_CLOSURE(self, info, inst): # -> None:
        ...
    
    def op_LOAD_CLOSURE(self, info, inst): # -> None:
        ...
    
    def op_LOAD_METHOD(self, *args, **kws): # -> None:
        ...
    
    def op_CALL_METHOD(self, *args, **kws): # -> None:
        ...
    


class LoopBlock:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    


class WithBlock:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    


class BlockInfo:
    def __init__(self, block, offset, incoming_blocks) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def dump(self): # -> None:
        ...
    
    def make_temp(self, prefix=...): # -> str:
        ...
    
    def push(self, val): # -> None:
        ...
    
    def pop(self, discard=...): # -> str | None:
        """
        Pop a variable from the stack, or request it from incoming blocks if
        the stack is empty.
        If *discard* is true, the variable isn't meant to be used anymore,
        which allows reducing the number of temporaries created.
        """
        ...
    
    def peek(self, k): # -> str | None:
        """
        Return the k'th element back from the top of the stack.
        peek(1) is the top of the stack.
        """
        ...
    
    def make_incoming(self): # -> str:
        """
        Create an incoming variable (due to not enough values being
        available on our stack) and request its assignment from our
        incoming blocks' own stacks.
        """
        ...
    
    def request_outgoing(self, outgoing_block, phiname, stack_index): # -> None:
        """
        Request the assignment of the next available stack variable
        for block *outgoing_block* with target name *phiname*.
        """
        ...
    
    @property
    def tos(self): # -> str | None:
        ...
    
    def append(self, inst, **kws): # -> None:
        ...
    
    @property
    def terminator(self): # -> None:
        ...
    
    @terminator.setter
    def terminator(self, inst): # -> None:
        ...
    
    @property
    def active_try_block(self): # -> None:
        """Try except not supported.

        See byteflow.py
        """
        ...
    


