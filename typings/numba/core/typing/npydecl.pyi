"""
This type stub file was generated by pyright.
"""

import numpy as np
import operator
from numba.core.typing.templates import AbstractTemplate, CallableTemplate
from numba.np.numpy_support import carray, farray
from numba import pndindex
from numba.core.overload_glue import glue_typing

registry = ...
infer = ...
infer_global = ...
infer_getattr = ...
class Numpy_rules_ufunc(AbstractTemplate):
    @property
    def ufunc(self):
        ...
    
    def generic(self, args, kws): # -> Signature:
        ...
    


class NumpyRulesArrayOperator(Numpy_rules_ufunc):
    _op_map = ...
    @property
    def ufunc(self): # -> Any:
        ...
    
    @classmethod
    def install_operations(cls): # -> None:
        ...
    
    def generic(self, args, kws): # -> Signature | None:
        '''Overloads and calls base class generic() method, returning
        None if a TypingError occurred.

        Returning None for operators is important since operators are
        heavily overloaded, and by suppressing type errors, we allow
        type inference to check other possibilities before giving up
        (particularly user-defined operators).
        '''
        ...
    


_binop_map = ...
class NumpyRulesInplaceArrayOperator(NumpyRulesArrayOperator):
    _op_map = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


class NumpyRulesUnaryArrayOperator(NumpyRulesArrayOperator):
    _op_map = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


_math_operations = ...
_trigonometric_functions = ...
_bit_twiddling_functions = ...
_comparison_functions = ...
_floating_functions = ...
_logic_functions = ...
_unsupported = ...
_aliases = ...
if np.divide == np.true_divide:
    ...
all_ufuncs = ...
supported_ufuncs = ...
all_ufuncs = ...
supported_ufuncs = ...
supported_array_operators = ...
class Numpy_method_redirection(AbstractTemplate):
    """
    A template redirecting a Numpy global function (e.g. np.sum) to an
    array method of the same name (e.g. ndarray.sum).
    """
    prefer_literal = ...
    def generic(self, args, kws): # -> None:
        ...
    


np_types = ...
def register_number_classes(register_global): # -> None:
    ...

def parse_shape(shape): # -> int | None:
    """
    Given a shape, return the number of dimensions.
    """
    ...

def parse_dtype(dtype): # -> Record | Boolean | Integer | Float | Complex | PyObject | UnicodeCharSeq | CharSeq | NPTimedelta | NPDatetime | NestedArray | None:
    """
    Return the dtype of a type, if it is either a DtypeSpec (used for most
    dtypes) or a TypeRef (used for record types).
    """
    ...

@glue_typing(np.array)
class NpArray(CallableTemplate):
    """
    Typing template for np.array().
    """
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.full)
class NdFull(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.full_like)
class NdFullLike(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        """
        np.full_like(array, val) -> array of the same shape and layout
        np.full_like(scalar, val) -> 0-d array of the scalar type
        """
        ...
    


@glue_typing(np.identity)
class NdIdentity(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.linspace)
class NdLinspace(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.frombuffer)
class NdFromBuffer(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.sort)
class NdSort(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.asfortranarray)
class AsFortranArray(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.ascontiguousarray)
class AsContiguousArray(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.copy)
class NdCopy(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.expand_dims)
class NdExpandDims(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


class BaseAtLeastNdTemplate(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.atleast_1d)
class NdAtLeast1d(BaseAtLeastNdTemplate):
    def convert_array(self, a):
        ...
    


@glue_typing(np.atleast_2d)
class NdAtLeast2d(BaseAtLeastNdTemplate):
    def convert_array(self, a):
        ...
    


@glue_typing(np.atleast_3d)
class NdAtLeast3d(BaseAtLeastNdTemplate):
    def convert_array(self, a):
        ...
    


@glue_typing(np.concatenate)
class NdConcatenate(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.stack)
class NdStack(CallableTemplate):
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


class BaseStackTemplate(CallableTemplate):
    def generic(self): # -> Callable[..., Array]:
        ...
    


@glue_typing(np.hstack)
class NdStack(BaseStackTemplate):
    func_name = ...
    ndim_min = ...


@glue_typing(np.vstack)
class NdStack(BaseStackTemplate):
    func_name = ...
    ndim_min = ...


@glue_typing(np.dstack)
class NdStack(BaseStackTemplate):
    func_name = ...
    ndim_min = ...


@glue_typing(np.column_stack)
class NdColumnStack(CallableTemplate):
    def generic(self): # -> Callable[..., Array]:
        ...
    


class MatMulTyperMixin:
    def matmul_typer(self, a, b, out=...): # -> Array | Float | Complex | None:
        """
        Typer function for Numpy matrix multiplication.
        """
        ...
    


@glue_typing(np.dot)
class Dot(MatMulTyperMixin, CallableTemplate):
    func_name = ...
    def generic(self): # -> Callable[..., Array | Float | Complex | None]:
        ...
    


@glue_typing(np.vdot)
class VDot(CallableTemplate):
    def generic(self): # -> Callable[..., Float | Complex | None]:
        ...
    


@infer_global(operator.matmul)
class MatMul(MatMulTyperMixin, AbstractTemplate):
    key = ...
    func_name = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(np.ndenumerate)
class NdEnumerate(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(np.nditer)
class NdIter(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(pndindex)
@infer_global(np.ndindex)
class NdIndex(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.round)
@glue_typing(np.around)
class Round(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.where)
class Where(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.sinc)
class Sinc(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(np.angle)
class Angle(CallableTemplate):
    """
    Typing template for np.angle()
    """
    def generic(self): # -> Callable[..., Array | Any | Float | None]:
        ...
    


@glue_typing(np.diag)
class DiagCtor(CallableTemplate):
    """
    Typing template for np.diag()
    """
    def generic(self): # -> Callable[..., Array | None]:
        ...
    


@glue_typing(np.take)
class Take(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@glue_typing(carray)
class NumbaCArray(CallableTemplate):
    layout = ...
    def generic(self): # -> Callable[..., Array]:
        ...
    


@glue_typing(farray)
class NumbaFArray(NumbaCArray):
    layout = ...


