"""
This type stub file was generated by pyright.
"""

from numba.core import serialize

opcode_info = ...
_FIXED_OFFSET = ...
def get_function_object(obj): # -> Any:
    """
    Objects that wraps function should provide a "__numba__" magic attribute
    that contains a name of an attribute that contains the actual python
    function object.
    """
    ...

def get_code_object(obj): # -> Any | None:
    "Shamelessly borrowed from llpython"
    ...

JREL_OPS = ...
JABS_OPS = ...
JUMP_OPS = ...
TERM_OPS = ...
EXTENDED_ARG = ...
HAVE_ARGUMENT = ...
class ByteCodeInst:
    '''
    Attributes
    ----------
    - offset:
        byte offset of opcode
    - opcode:
        opcode integer value
    - arg:
        instruction arg
    - lineno:
        -1 means unknown
    '''
    __slots__ = ...
    def __init__(self, offset, opcode, arg, nextoffset) -> None:
        ...
    
    @property
    def is_jump(self): # -> bool:
        ...
    
    @property
    def is_terminator(self): # -> bool:
        ...
    
    def get_jump_target(self): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def block_effect(self): # -> Literal[1, -1, 0]:
        """Effect of the block stack
        Returns +1 (push), 0 (none) or -1 (pop)
        """
        ...
    


CODE_LEN = ...
ARG_LEN = ...
NO_ARG_LEN = ...
OPCODE_NOP = ...
class ByteCodeIter:
    def __init__(self, code) -> None:
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def next(self): # -> tuple[int, ByteCodeInst]:
        ...
    
    __next__ = ...
    def read_arg(self, size): # -> int:
        ...
    


class ByteCode:
    """
    The decoded bytecode of a function, and related information.
    """
    __slots__ = ...
    def __init__(self, func_id) -> None:
        ...
    
    def __iter__(self): # -> Iterator[ByteCodeInst]:
        ...
    
    def __getitem__(self, offset): # -> ByteCodeInst:
        ...
    
    def __contains__(self, offset): # -> bool:
        ...
    
    def dump(self): # -> str:
        ...
    
    def get_used_globals(self): # -> dict[Any, Any]:
        """
        Get a {name: value} map of the globals used by this code
        object and any nested code objects.
        """
        ...
    


class FunctionIdentity(serialize.ReduceMixin):
    """
    A function's identity and metadata.

    Note this typically represents a function whose bytecode is
    being compiled, not necessarily the top-level user function
    (the two might be distinct, e.g. in the `@generated_jit` case).
    """
    _unique_ids = ...
    @classmethod
    def from_function(cls, pyfunc): # -> Self:
        """
        Create the FunctionIdentity of the given function.
        """
        ...
    
    def derive(self): # -> Self:
        """Copy the object and increment the unique counter.
        """
        ...
    


